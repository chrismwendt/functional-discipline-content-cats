module Typedefs.Backend

import Data.Vect
import Data.NEList

import Typedefs.Text
import Typedefs.Names
import Typedefs.Typedefs
import Typedefs.Backend.Data

import Text.PrettyPrint.WL

%default total
%access public export

||| Proof that a type constuctor indexed on Nat is indexed on Z or if its unbounded
|||
||| `ZeroOrUnbounded p True` means `p` is unbounded
||| `ZeroOrUnbounded p False` means `p` is indexed with `Z`
data ZeroOrUnbounded : (Nat -> Type) -> Bool -> Type where
  Unbounded : p n -> ZeroOrUnbounded p True
  Zero : p Z -> ZeroOrUnbounded p False

||| Checks if the bound assumed on an indexed type is the correct one
fromSigma : {p : Nat -> Type} -> (bounded : Bool) -> (n ** p n)
         -> Either CompilerError (ZeroOrUnbounded p bounded)
fromSigma True  (n  **pn) = Right $ Unbounded $ pn
fromSigma False (Z  **pz) = Right $ Zero $ pz
fromSigma False (S _** _) = Left $ UnknownError "Inconsistent bound"

||| Interface for interpreting type definitions as ASTs.
||| @def      the type representing definitions.
||| @type     the type representing types.
||| @freeVars flag controlling if type definition can have free variables.
interface ASTGen def type (freeVars : Bool) | def where
  ||| Given a list of `TNamed`, generate their corresponding type signatures.
  msgType          : ZeroOrUnbounded TNamedR freeVars          -> Either CompilerError type

  ||| Generate definitions for a list of `TNamed`.
  generateTyDefs   : List Name -> NEList (ZeroOrUnbounded TNamedR freeVars) -> Either CompilerError (List def)

  ||| Generate serialisation and deserialisation term definitions for a
  ||| a `TNamed` and all its helper definitions.
  generateTermDefs : NEList (ZeroOrUnbounded TNamedR freeVars) -> Either CompilerError (List def)

||| Interface for code generators that can generate code for type definitions and
||| type signatures independently of each other, for example Haskell and ReasonML.
||| @def  the type representing definitions.
||| @type the type representing types.
interface CodegenIndep def type | def where
  ||| Generate source code for a type signature.
  typeSource : type -> Doc

  ||| Generate source code for a type definition.
  defSource  : def -> Doc

  ||| A common preamble that code generated by `typeSource` and
  ||| `defSource` may use.
  preamble : Doc

||| Use the given backend to generate code for a list of type definitions.
generateDefs : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => TopLevelDef -> Either CompilerError Doc
generateDefs {fv} def (MkTopLevelDef sp tns) = (traverse (fromSigma fv) tns) >>= generateDefinitions
  where
    generateDefinitions : NEList (ZeroOrUnbounded TNamedR fv) -> Either CompilerError Doc
    generateDefinitions nel = do defs <- generateTyDefs {def} sp nel
                                 terms <- generateTermDefs {def} nel
                                 pure $ vsep2 $ (preamble {def}) :: (defSource <$> defs ++ terms)

||| Use the given backend to generate code for a list of type signatures.
generateType' : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => NEList (n ** TNamedR n) -> Either CompilerError Doc
generateType' {fv} def tns =
  typeSource {def} <$> (concatMap (msgType {def})) !(traverse (fromSigma fv) tns)

||| Here for compatiblity purposes with tests
generateType : (def : Type) -> (ASTGen def type fv, CodegenIndep def type) => NEList (n ** TNamedR n) -> Maybe Doc
generateType {fv} def tns = eitherToMaybe $ generateType' def tns

||| Interface for code generators that need to generate code for type definitions and
||| type signatures at the same time, for example the JSON schema backend.
||| @def  the type representing type definitions.
||| @type the type representing type signatures.
interface CodegenInterdep def type where
  ||| Generate source code for a type signature and a list of helper definitions.
  sourceCode   : NEList type -> List def -> Doc

||| Use the given backend to generate code for a list of type definitions.
generate' : (def : Type) -> (ASTGen def type fv, CodegenInterdep def type) => NEList (n ** TNamedR n) -> Either CompilerError Doc
generate' {fv} def tns = (traverse (fromSigma fv) tns) >>= generateDefinitions
  where
    generateDefinitions : NEList (ZeroOrUnbounded TNamedR fv) -> Either CompilerError Doc
    generateDefinitions nel = do types <- traverse (msgType {def}) nel
                                 defs <- generateTyDefs {def} [] nel
                                 terms <- generateTermDefs {def} nel
                                 pure $ sourceCode types (defs ++ terms)

||| Here for compatibilty purposes with tests
generate : (def : Type) -> (ASTGen def type fv, CodegenInterdep def type) => NEList (n ** TNamedR n) -> Maybe Doc
generate {fv} def tns = eitherToMaybe $ generate' def tns

