<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (bastet.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – bastet</nav><nav class="toc"><ul><li><a href="#top">Bastet</a><ul><li><a href="#project-layout">Project Layout</a></li><li><a href="#who-is-this-for?">Who is this for?</a></li><li><a href="#a-succinct-introduction">A Succinct Introduction</a><ul><li><a href="#functors">Functors</a></li><li><a href="#magmas">Magmas</a></li><li><a href="#monoidal-categories">Monoidal Categories</a><ul><li><a href="#general-overview">General Overview</a></li><li><a href="#monoid">Monoid</a></li><li><a href="#plus">Plus</a></li><li><a href="#monad">Monad</a><ul><li><a href="#example">Example</a></li><li><a href="#monoid-laws">Monoid Laws</a></li><li><a href="#io">IO</a></li></ul></li><li><a href="#category">Category</a></li></ul></li><li><a href="#comparisons">Comparisons</a></li><li><a href="#rings">Rings</a></li><li><a href="#lattices">Lattices</a></li><li><a href="#further-reading">Further Reading</a></li></ul></li><li><a href="#ppx-let">PPX Let</a></li><li><a href="#background">Background</a></li></ul></li></ul></nav></header><h2 id="top"><a href="#top" class="anchor"></a>Bastet</h2><p><i>Bastet</i> is a ReasonML/Ocaml library for category theory and abstract algebra. The entry point of this library is the module: <a href="Bastet/index.html"><code>Bastet</code></a>.</p><h3 id="project-layout"><a href="#project-layout" class="anchor"></a>Project Layout</h3><ul><li><a href="Bastet/Interface/index.html"><code>Bastet.Interface</code></a> provides the category theory and abstract algebra interfaces.</li><li><a href="Bastet/Infix/index.html"><code>Bastet.Infix</code></a> provides functors to generate infix operators for the interfaces. Implementations in this library already have instantiated infix submodules for convenience.</li><li><a href="Bastet/Default/index.html"><code>Bastet.Default</code></a> provides default implementations for interface functions.</li><li><a href="Bastet/Functors/index.html"><code>Bastet.Functors</code></a> provides already instantiated functors for common data combinations for convenience.</li><li><a href="Bastet/Functions/index.html"><code>Bastet.Functions</code></a> provides generic functions that are built on top the abstract interfaces.</li><li><a href="Bastet/PPX_Let/index.html"><code>Bastet.PPX_Let</code></a> privides helpers for integrating with the <a href="https://opam.ocaml.org/packages/ppx_let">ppx_let</a> package.</li><li><a href="Bastet/Verify/index.html"><code>Bastet.Verify</code></a> provides property based tests to verify that implementations are lawful.</li><li><a href="Bastet/Test/index.html"><code>Bastet.Test</code></a> provides generic tests that can be combined with any frontend or backend unit and generative test framework.</li></ul><p>There are also implementations for these builtin Ocaml data types:</p><ul><li><a href="Bastet/Array/index.html"><code>Bastet.Array</code></a></li><li><a href="Bastet/Bool/index.html"><code>Bastet.Bool</code></a></li><li><a href="Bastet/Dual/index.html"><code>Bastet.Dual</code></a></li><li><a href="Bastet/Endo/index.html"><code>Bastet.Endo</code></a></li><li><a href="Bastet/Float/index.html"><code>Bastet.Float</code></a></li><li><a href="Bastet/Function/index.html"><code>Bastet.Function</code></a></li><li><a href="Bastet/Int/index.html"><code>Bastet.Int</code></a></li><li><a href="Bastet/List/index.html"><code>Bastet.List</code></a></li><li><a href="Bastet/Option/index.html"><code>Bastet.Option</code></a></li><li><a href="Bastet/String/index.html"><code>Bastet.String</code></a></li><li><a href="Bastet/Tuple/index.html"><code>Bastet.Tuple</code></a></li><li><a href="Bastet/Result/index.html"><code>Bastet.Result</code></a></li></ul><h3 id="who-is-this-for?"><a href="#who-is-this-for?" class="anchor"></a>Who is this for?</h3><p>This library is intended for those who want to write highly reusable functional code. Category theory and abstract algebra is a perfect foundation for this because of functional programming's close relationship with pure math — functions in this context are closer to the mathematical sense of the word rather than something like a subroutine.</p><p>But unless your entire team is already familiar with these principles, it's recommended that library authors provide a <i>concrete</i> API that doesn't expose this level of abstraction for newcomers.</p><p>For example, consider this abstraction that generalizes the notion of something similar to the <a href="Bastet/Result/index.html#val-hush"><code>Bastet.Result.hush</code></a> function but instead returns a <code>unit</code> type for the second type argument instead of an <code>option</code> type:</p><pre><code class="ml"># #require &quot;bastet&quot;;;
# open Bastet;;

# module Hush (B : Interface.BIFUNCTOR) =
  struct let hush bifunctor = bifunctor |&gt; B.bimap Function.Category.id (Function.const ()) end;;
module Hush :
  functor (B : Bastet.Interface.BIFUNCTOR) -&gt;
    sig val hush : ('a, 'b) B.t -&gt; ('a, unit) B.t end

# module Hush_Result = Hush (Result.Bifunctor)
module Hush_Result : sig val hush : ('a, 'b) result -&gt; ('a, unit) result end

# let hush = Hush_Result.hush
val hush : ('a, 'b) result -&gt; ('a, unit) result = &lt;fun&gt;</code></pre><p>In this example, the (abstract) <code>Hush</code> functor would be exposed to other library authors while the (concrete) <code>hush</code> function with some docs would be exposed only to the newcomers.</p><p>This way anyone can still take advantage of the derived implementations provided by this abstraction without any of the learning curve — they can just read the type signature of the <code>hush</code> function and ignore the other stuff. And the functor could be reused for some other type that takes two parameters, such as a tuple, map, or record.</p><h3 id="a-succinct-introduction"><a href="#a-succinct-introduction" class="anchor"></a>A Succinct Introduction</h3><p>The downside to using such abstractions is that newcomers are often overwhelmed. They might not know how much category theory or abstract algebra they need to formally know (almost none), or whether or not to read monad tutorials (you shouldn't). The best way to learn this stuff is to read the <code>module
type</code>s and the laws that the types need to satisfy. This succinct and hopeful more useful introduction is ideally all you will need to understand the core concepts and be productive.</p><p>You can try all of the examples here with <a href="https://opam.ocaml.org/packages/utop">utop</a>.</p><h4 id="functors"><a href="#functors" class="anchor"></a>Functors</h4><p>Functors generalize the notion of something that's <i>composably mappable</i>. You're probably already familiar with this concept from javascript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a> function.</p><p>Here's what it looks like in Ocaml:</p><pre><code class="ml"># Array.map (( * ) 2) [|1; 2; 3|];;
- : int array = [|2; 4; 6|]

# Array.map string_of_int [|1; 2; 3|];;
- : string array = [|&quot;1&quot;; &quot;2&quot;; &quot;3&quot;|]</code></pre><p>In order for a type to be a functor, it needs to have a <code>map</code> function that also satisfies two laws. The laws ensure that the <code>map</code> function works well with function composition:</p><ul><li><p>The Identity Law:</p><p><code>map id x = x</code></p><p>In this context, <code>id</code> is the identity function (<a href="Bastet/Function/Category/index.html#val-id"><code>Bastet.Function.Category.id</code></a>). It's the simplest function imaginable: it just returns the value given to it. It's written like this in Ocaml:</p><pre><code class="ml"># let id x = x;;
val id : 'a -&gt; 'a = &lt;fun&gt;

# id 123;;
- : int = 123

# id &quot;foo&quot;;;
- : string = &quot;foo&quot;</code></pre><p>This law is saying is that if I call <code>map</code> on a functor and I don't do anything to the elements because I'm calling <code>map</code> with the <code>id</code> function, then I should get back the same collection. This is important to achieve the notion that functors should be <i>composably mappable</i>.</p></li><li><p>The Composition Law</p><p><code>map (compose g f) x = compose (map g) (map f) x</code></p><p>And <code>compose</code> is just function composition:</p><pre><code class="ml"># let compose f g x = f (g x);;
val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;</code></pre></li></ul><p>Thsee laws describe what's meant by <i>composably mappable</i>: the <code>map</code> function together with function composition (<code>compose</code>) should be sort of <a href="https://en.m.wikipedia.org/wiki/Distributive_property">right-distributive</a> and work together in a nice way.</p><p>Here are some concerete examples:</p><ul><li>The <a href="Bastet/Array/Functor/index.html"><code>Bastet.Array.Functor</code></a> from the earlier example</li><li><p>The <a href="Bastet/List/Functor/index.html"><code>Bastet.List.Functor</code></a></p><pre><code class="ml"># let id x = x;;
val id : 'a -&gt; 'a = &lt;fun&gt;

# let compose f g x = f (g x);;
val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

# let satisfies_identity = List.map id [1; 2; 3] = [1; 2; 3];;
val satisfies_identity : bool = true

# let satisfies_composition =
  List.map (compose string_of_int ((+) 1)) [1; 2; 3] =
  compose (List.map string_of_int) (List.map ((+) 1)) [1; 2; 3];;
val satisfies_composition : bool = true</code></pre></li><li><p>The <a href="Bastet/Option/Functor/index.html"><code>Bastet.Option.Functor</code></a></p><pre><code class="ml"># let id x = x;;
val id : 'a -&gt; 'a = &lt;fun&gt;

# let compose f g x = f (g x);;
val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

# let map f = function
  | Some value -&gt; Some (f value)
  | None -&gt; None;;
val map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option = &lt;fun&gt;

# let satisfies_identity = map id (Some 123) = Some 123;;
val satisfies_identity : bool = true

# let satisfies_composition =
  map (compose string_of_int ((+) 1)) (Some 123) =
  compose (map string_of_int) (map ((+) 1)) (Some 123);;
val satisfies_composition : bool = true</code></pre></li></ul><h4 id="magmas"><a href="#magmas" class="anchor"></a>Magmas</h4><p>Magmas are a very simple concept: it's just a set (or type) with a single binary operation, and that binary operation must be closed under that set. That just means it takes two arguments of the same type and returns the same type. You're already familiar with several magmas:</p><pre><code class="ml"># (+);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# (-);;
- : int -&gt; int -&gt; int = &lt;fun&gt;
# (+.);;
- : float -&gt; float -&gt; float = &lt;fun&gt;
# (/.);;
- : float -&gt; float -&gt; float = &lt;fun&gt;
# (&amp;&amp;);;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;
# (||);;
- : bool -&gt; bool -&gt; bool = &lt;fun&gt;</code></pre><p>No additional laws or conditions need to be satisfied. This is extremely useful when you want to be able to write abstractions that work for <i>any</i> binary operation that's closed:</p><pre><code class="ml"># module List_Apply (M: Interface.MAGMA) =
  struct let apply init list = ListLabels.fold_left ~f:M.append ~init list end;;
module List_Apply :
  functor (M : Bastet.Interface.MAGMA) -&gt;
    sig val apply : M.t -&gt; M.t list -&gt; M.t end

# module List_Additive_Int_Apply = List_Apply(Int.Additive.Magma);;
module List_Additive_Int_Apply : sig val apply : int -&gt; int list -&gt; int end

# module List_Subtractive_Int_Apply = List_Apply(Int.Subtractive.Magma);;
module List_Subtractive_Int_Apply : sig val apply : int -&gt; int list -&gt; int end

# let adder = List_Additive_Int_Apply.apply;;
val adder : int -&gt; int list -&gt; int = &lt;fun&gt;

# let subtractor = List_Subtractive_Int_Apply.apply;;
val subtractor : int -&gt; int list -&gt; int = &lt;fun&gt;

# [1; 2; 3] |&gt; adder 0 = (0 + 1 + 2 + 3);;
- : bool = true

# [1; 2; 3] |&gt; subtractor 10 = (10 - 1 - 2 - 3);;
- : bool = true</code></pre><p>This example provides a generic functor that works on any magma. Some concrete instances are constructed for <a href="Bastet/Int/Additive/Magma/index.html"><code>Bastet.Int.Additive.Magma</code></a> and <a href="Bastet/Int/Subtractive/Magma/index.html"><code>Bastet.Int.Subtractive.Magma</code></a>.</p><p>As you can see it can be pretty useful. One of the benefits of magmas is that it's very general because you don't need to satisfy any additional laws.</p><p>You might ask: why not just use <a href="#monoid">monoids</a>? Integer subtraction (<code>-</code>) can't be a monoid because although it has an empty element (<code>0</code>), it's not <i>associative</i> — the <i>evaluation order</i> of the operations matter:</p><pre><code class="ml"># 10 - (1 - 2) = (10 - 1) - 2;;
- : bool = false</code></pre><p>And obviously you'll probably eventually run into a situation where you need to subtract everything in a <code>list</code> or <code>array</code> starting from some initial value, which is where magmas shine. Monoids will be exlpained more in the next section.</p><h4 id="monoidal-categories"><a href="#monoidal-categories" class="anchor"></a>Monoidal Categories</h4><p><i>- &quot;A monad is just a monoid in the category of endofunctors, what's the problem?&quot;</i></p><p>This quote is often cited in the FP community as a joke. The joke is that the sentence sounds extremely complicated because of the jargon, but it's actually the easiest way of understanding monads.</p><p>By the end of this section you'll learn about the different categories of monoids (like monads) and why monads are used for <code>IO</code>. The goal ideally is that you'll leave this section without feeling the need to pick up any other resource for monads because you get it now.</p><h5 id="general-overview"><a href="#general-overview" class="anchor"></a>General Overview</h5><p>This section provides a general overview of monoids. This is one subsection that you might not get immediately. Because of the level of abstraction, it's recommended that you don't spend a lot of time on this section, and instead come back to it after reading the subsequent sections and writing code that uses this stuff to get a feel for it.</p><p>The idea of a monoid is to represent something that's <i>appendable</i> or combinable in a general way.</p><p>Monoids come up constantly in programming because we're more or less just <i>combining</i> things: a construction worker is a civic developer, and for the most part we're white-collar construction workers (software developers).</p><p>You can obviously combine things that are of different types, otherwise we wouldn't be able to build anything really interesting or useful with software. A monoid specifically describes combining something of the same type and returning the same type.</p><p>We know that we need a magma because we're taking two things of the same type and returning the same type. But as you saw in the previous section, a magma isn't enough to describe something that's appendable because subtraction is a magma, and subtraction <i>doesn't combine</i> or add two things together, it takes something away.</p><p>What's really needed is a magma that satisfies two <i>laws</i> in order to truly describe something that's appendable:</p><ul><li><p>The <a href="https://en.m.wikipedia.org/wiki/Associative_property">Law of Associativity</a>:</p><pre><code class="ml">a • (b • c) = (a • b) • c</code></pre><p>Where the <code>•</code> operation is a placeholder for the operation used in the magma's implementation. Some concrete examples are addition (<code>+</code>) and multiplication (<code>*</code>):</p><pre><code class="ml"># 1 + (2 + 3) = (1 + 2) + 3;;
- : bool = true
# 1 * (2 * 3) = (1 * 2) * 3;;
- : bool = true</code></pre><p>And as you saw in the previous section, subtraction isn't associative so it can't describe something that appends things. Another example is division, which is also a magma but isn't associative, and consequently it doesn't describe combining anything but rather <i>splitting</i> something up instead.</p></li><li><p>The <a href="https://en.m.wikipedia.org/wiki/Identity_element">Law of Identity</a> with an <code>identity</code> element called <code>empty</code>:</p><pre><code class="ml">a • empty = a</code></pre><p>The law states that using the operation on the empty element just returns the same element. Here are some concrete examples:</p><pre><code class="ml"># let empty = 0;;
val empty : int = 0
# 10 + empty = 10;;
- : bool = true

# let empty = 1;;
val empty : int = 1
# 5 * empty = 5;;
- : bool = true

# let empty = &quot;&quot;;;
val empty : string = &quot;&quot;
# &quot;foo&quot; ^ empty = &quot;foo&quot;;;
- : bool = true</code></pre><p>In these examples, <code>((+), 0)</code>, <code>(( * ), 1)</code>, and <code>((^), &quot;&quot;)</code> are all monoids: all of those operations are associative, and if you pair those operations with those specific values as the empty elemnt then it satisfies the identity law as well.</p></li></ul><h5 id="monoid"><a href="#monoid" class="anchor"></a>Monoid</h5><p>After reading the previous section, you might not have understood everything fully and that's <i>ok</i>. It's best to see some concrete examples of functions that you've often used in order to get a wholistic perspective of what's going on.</p><ul><li><p>The <a href="Bastet/Int/Additive/Monoid/index.html"><code>Bastet.Int.Additive.Monoid</code></a></p><p><code>(+)</code> with <code>0</code> as the empty element <code>((+), 0)</code>:</p><pre><code class="ml"># let empty = 0;;
val empty : int = 0

# let satisfies_identity_law = 10 + empty = 10;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law = 1 + (2 + 3) = (1 + 2) + 3;;
val satisfies_associative_law : bool = true</code></pre></li><li><p>The <a href="Bastet/Int/Multiplicative/Monoid/index.html"><code>Bastet.Int.Multiplicative.Monoid</code></a></p><p><code>( * )</code> with <code>1</code> as the empty element <code>(( * ), 1)</code>:</p><pre><code class="ml"># let empty = 1;;
val empty : int = 1

# let satisfies_identity_law = 10 * empty = 10;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law = 1 * (2 * 3) = (1 * 2) * 3;;
val satisfies_associative_law : bool = true</code></pre></li><li><p>The <a href="Bastet/Bool/Conjunctive/Monoid/index.html"><code>Bastet.Bool.Conjunctive.Monoid</code></a></p><p><code>(&amp;&amp;)</code> with <code>true</code> as the empty element <code>((&amp;&amp;), true)</code>:</p><pre><code class="ml"># let empty = true;;
val empty : bool = true

# let satisfies_identity_law = (false &amp;&amp; empty) = false;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law = (true &amp;&amp; (true &amp;&amp; false)) = ((true &amp;&amp; true) &amp;&amp; false);;
val satisfies_associative_law : bool = true</code></pre></li><li><p>The <a href="Bastet/Bool/Disjunctive/Monoid/index.html"><code>Bastet.Bool.Disjunctive.Monoid</code></a></p><p><code>(||)</code> with <code>false</code> as the empty element <code>((||), false)</code>:</p><pre><code class="ml"># let empty = false;;
val empty : bool = false

# let satisfies_identity_law = (true || empty) = true;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law = (true || (true || false)) = ((true || true) || false);;
val satisfies_associative_law : bool = true</code></pre></li><li><p>The <a href="Bastet/String/Monoid/index.html"><code>Bastet.String.Monoid</code></a></p><p><code>(^)</code> with <code>&quot;&quot;</code> as the empty element <code>((^), &quot;&quot;)</code>:</p><pre><code class="ml"># let empty = &quot;&quot;;;
val empty : string = &quot;&quot;

# let satisfies_identity_law = &quot;foo&quot; ^ empty = &quot;foo&quot;;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law = &quot;foo&quot; ^ (&quot;bar&quot; ^ &quot;baz&quot;) = (&quot;foo&quot; ^ &quot;bar&quot;) ^ &quot;baz&quot;;;
val satisfies_associative_law : bool = true</code></pre></li></ul><h5 id="plus"><a href="#plus" class="anchor"></a>Plus</h5><p><a href="Bastet/Interface/module-type-PLUS/index.html"><code>Bastet.Interface.PLUS</code></a> is a <i>monoid in the category of functors</i>.</p><p>Unlike a <a href="#monoid">monoid</a>, it's a <a href="#functor">functor</a> so it's type has a type parameter <i>'a</i>: instead of having a type <code>t</code> where t is a concerete type (ie: <code>string</code>, <code>int</code>), it instead has a type <code>'a t</code> where the <i>'a</i> can be anything (ie: <code>'a list</code>, <code>'a option</code>).</p><p>It satisfies the monoid laws at the functor level:</p><ul><li><p>The <a href="Bastet/List/Plus/index.html"><code>Bastet.List.Plus</code></a></p><p><code>List.append</code> with <code>[]</code> as the empty element <code>(List.append, [])</code>:</p><pre><code class="ml"># let empty: int list = [];;
val empty : int list = []

# let satisfies_identity_law = List.append [1; 2; 3] empty = [1; 2; 3];;
val satisfies_identity_law : bool = true

# let satisfies_associative_law =
  List.append [1] (List.append [2; 3] [4]) = List.append (List.append [1] [2; 3]) [4];;
val satisfies_associative_law : bool = true</code></pre></li><li><p>The <a href="Bastet/Option/Plus/index.html"><code>Bastet.Option.Plus</code></a></p><pre><code class="ml"># let empty: [ `foo ] option = None;;
val empty : [ `foo ] option = None

# let append a b =
  match a, b with
  | Some x, _ -&gt; Some x
  | None, y -&gt; y;;
val append : 'a option -&gt; 'a option -&gt; 'a option = &lt;fun&gt;

# let satisfies_identity_law = append (Some `foo) empty = Some `foo;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law =
  append None (append (Some `foo) (Some `bar)) =
  append (append None (Some `foo)) (Some `bar);;
val satisfies_associative_law : bool = true</code></pre></li></ul><h5 id="monad"><a href="#monad" class="anchor"></a>Monad</h5><p><a href="Bastet/Interface/module-type-MONAD/index.html"><code>Bastet.Interface.MONAD</code></a> is a <i>monoid in the category of endofunctors</i>.</p><p>Monads are endofunctors: they're <a href="#functors">functors</a> that have a <code>pure</code> function that can be thought of as a constructor function, and a <code>flatten</code> function that flattens the nested type.</p><p>It's common practice to provide a <code>flat_map</code> function directly instead of a <code>flatten</code> function. The <code>flat_map</code> function can be derived from <code>flat_map f = compose flatten (map f)</code>, and vice-versa. For the purposes of this section, it's best to think of monads as functors that provide additional <code>pure</code> and <code>flatten</code> functions and satisfies the monoid laws.</p><h6 id="example"><a href="#example" class="anchor"></a>Example</h6><p>Here's an example of <a href="Bastet/Option/Monad/index.html"><code>Bastet.Option.Monad</code></a>:</p><pre><code class="ml"># let compose f g x = f (g x);;
val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

# let pure a = Some a;;
val pure : 'a -&gt; 'a option = &lt;fun&gt;

# let map f = function
  | Some value -&gt; Some (f value)
  | None -&gt; None;;
val map : ('a -&gt; 'b) -&gt; 'a option -&gt; 'b option = &lt;fun&gt;

# let flatten: 'a option option -&gt; 'a option = function
  | Some value -&gt; value
  | None -&gt; None;;
val flatten : 'a option option -&gt; 'a option = &lt;fun&gt;

# let flat_map f = compose flatten (map f);;
val flat_map : ('a -&gt; 'b option) -&gt; 'a option -&gt; 'b option = &lt;fun&gt;

# let (&gt;&gt;=) a b = flat_map b a;;
val ( &gt;&gt;= ) : 'a option -&gt; ('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;


# (* Another style of working with monads instead of flat_map is to use
     kliesli composition: *)
  let kliesli_compose f g a = f a &gt;&gt;= g;;
val kliesli_compose :
  ('a -&gt; 'b option) -&gt; ('b -&gt; 'c option) -&gt; 'a -&gt; 'c option = &lt;fun&gt;

# let (&gt;=&gt;) = kliesli_compose;;
val ( &gt;=&gt; ) : ('a -&gt; 'b option) -&gt; ('b -&gt; 'c option) -&gt; 'a -&gt; 'c option =
  &lt;fun&gt;


# (* Here's an example use case of option types as monads - getting deeply nested
     optional properties: *);;

# type user_details = { phone_number: int option; address: string option };;
type user_details = { phone_number : int option; address : string option; }

# type user = { name: string; details: user_details option };;
type user = { name : string; details : user_details option; }

# let fetch_user name =
  match name with
  | &quot;Risto&quot; -&gt;
    Some { name; details = Some { phone_number = None; address = Some &quot;123 Foo St&quot; } }
  | _ -&gt; None;;
val fetch_user : string -&gt; user option = &lt;fun&gt;

# let get_details user = user.details;;
val get_details : user -&gt; user_details option = &lt;fun&gt;

# let get_address details = details.address;;
val get_address : user_details -&gt; string option = &lt;fun&gt;

# (* With monads, getting values from deeply nested optional values is trivial: *)
  fetch_user &quot;Risto&quot; &gt;&gt;= get_details &gt;&gt;= get_address;;
- : string option = Some &quot;123 Foo St&quot;

# (* It's also trivial to turn this into a function with kliesli composition,
     which can makes things easier to read: *)
  let fetch_user_address = fetch_user &gt;=&gt; get_details &gt;=&gt; get_address;;
val fetch_user_address : string -&gt; string option = &lt;fun&gt;

# fetch_user_address &quot;Risto&quot;;;
- : string option = Some &quot;123 Foo St&quot;</code></pre><p>As you can see in the example, <code>kliesli_compose</code> can be derived entirely from <code>flat_map</code>.</p><h6 id="monoid-laws"><a href="#monoid-laws" class="anchor"></a>Monoid Laws</h6><p>Monads satisfy the monoid laws at the endofunctor level:</p><pre><code class="ml"># #require &quot;bastet&quot;
# open Bastet;;

# let (&gt;=&gt;) = Option.Infix.(&gt;=&gt;);;
val ( &gt;=&gt; ) : ('a -&gt; 'b option) -&gt; ('b -&gt; 'c option) -&gt; 'a -&gt; 'c option =
  &lt;fun&gt;

# let to_positive_int = function
  | x when x &gt; 0 -&gt; Some x
  | _ -&gt; None;;
val to_positive_int : int -&gt; int option = &lt;fun&gt;

# let to_even_int = function
  | x when x mod 2 = 0 -&gt; Some x
  | _ -&gt; None;;
val to_even_int : int -&gt; int option = &lt;fun&gt;

# let empty = Option.Monad.pure;;
val empty : 'a -&gt; 'a option = &lt;fun&gt;

# let satisfies_identity_law f value = (f &gt;=&gt; empty) value = f value;;
val satisfies_identity_law : ('a -&gt; 'b option) -&gt; 'a -&gt; bool = &lt;fun&gt;

# let satisfies_associative_law f g h value =
  (f &gt;=&gt; (g &gt;=&gt; h)) value = ((f &gt;=&gt; g) &gt;=&gt; h) value;;
val satisfies_associative_law :
  ('a -&gt; 'b option) -&gt; ('b -&gt; 'c option) -&gt; ('c -&gt; 'd option) -&gt; 'a -&gt; bool =
  &lt;fun&gt;

# satisfies_identity_law int_of_string_opt &quot;123&quot;;;
- : bool = true
# satisfies_identity_law to_positive_int 123;;
- : bool = true
# satisfies_identity_law to_even_int 123;;
- : bool = true

# satisfies_associative_law int_of_string_opt to_positive_int to_even_int &quot;123&quot;;;
- : bool = true
# satisfies_associative_law int_of_string_opt to_positive_int to_even_int &quot;foo&quot;;;
- : bool = true

# let string_to_positive_even_int =
  int_of_string_opt &gt;=&gt; to_positive_int &gt;=&gt; to_even_int;;
val string_to_positive_even_int : string -&gt; int option = &lt;fun&gt;
# string_to_positive_even_int &quot;foo&quot;;;
- : int option = None
# string_to_positive_even_int &quot;123&quot;;;
- : int option = None
# string_to_positive_even_int &quot;124&quot;;;
- : int option = Some 124</code></pre><h6 id="io"><a href="#io" class="anchor"></a>IO</h6><p>A good introduction on why monads are used for <code>IO</code> is to consider how javascript handles effects: using callbacks. This is called <a href="https://en.m.wikipedia.org/wiki/Continuation-passing_style">continuation passing style</a>.</p><p>A motivation for developing promises was to avoid callback hell:</p><pre><code class="ml">doSomeEffect(cb =&gt; {
  // do more stuff
  doSomeOtherEffect(cb =&gt; {
    // do more stuff
    doYetAnotherEffect(cb =&gt; {
      // do more stuff
    })
  })
})</code></pre><p>This example shows how you can use monads to flatten callbacks without having to use promises:</p><pre><code class="ml"># (* IO as a callback *)
  type 'a io = ('a -&gt; unit) -&gt; unit;;
type 'a io = ('a -&gt; unit) -&gt; unit

# let pure (value: 'a): 'a io = fun cb -&gt; cb value;;
val pure : 'a -&gt; 'a io = &lt;fun&gt;

# let map (f: 'a -&gt; 'b) (x: 'a io): 'b io =
  fun cb -&gt; x (fun value -&gt; cb (f value));;
val map : ('a -&gt; 'b) -&gt; 'a io -&gt; 'b io = &lt;fun&gt;

# let flat_map (f: 'a -&gt; 'b io) (x: 'a io): 'b io =
  fun cb -&gt; x (fun value -&gt; (f value) (fun value2 -&gt; cb value2));;
val flat_map : ('a -&gt; 'b io) -&gt; 'a io -&gt; 'b io = &lt;fun&gt;

# let (&gt;&gt;=) a b = flat_map b a;;
val ( &gt;&gt;= ) : 'a io -&gt; ('a -&gt; 'b io) -&gt; 'b io = &lt;fun&gt;

# let (&gt;=&gt;) f g a = f a &gt;&gt;= g;;
val ( &gt;=&gt; ) : ('a -&gt; 'b io) -&gt; ('b -&gt; 'c io) -&gt; 'a -&gt; 'c io = &lt;fun&gt;

# (* Some stubbed functions, assume they do something async: *);;
# let some_effect (x: int): int io = fun cb -&gt; cb (x * 2);;
val some_effect : int -&gt; int io = &lt;fun&gt;

# let some_other_effect (x: int): int io = fun cb -&gt; cb (x + 10);;
val some_other_effect : int -&gt; int io = &lt;fun&gt;

# let yet_another_effect (x: int): string io = fun cb -&gt; cb (string_of_int x);;
val yet_another_effect : int -&gt; string io = &lt;fun&gt;


# let empty = pure;;
val empty : 'a -&gt; 'a io = &lt;fun&gt;

# let satisfies_identity_law f arg =
  ((f &gt;=&gt; empty) arg) (fun value1 -&gt; begin
    (f arg) (fun value2 -&gt; Printf.printf &quot;%B\n&quot; (value1 = value2))
  end);;
val satisfies_identity_law : ('a -&gt; 'b io) -&gt; 'a -&gt; unit = &lt;fun&gt;

# let satisfies_associative_law f g h arg =
  ((f &gt;=&gt; (g &gt;=&gt; h)) arg) (fun value1 -&gt; begin
    (((f &gt;=&gt; g) &gt;=&gt; h) arg) (fun value2 -&gt; Printf.printf &quot;%B\n&quot; (value1 = value2))
  end);;
val satisfies_associative_law :
  ('a -&gt; 'b io) -&gt; ('b -&gt; 'c io) -&gt; ('c -&gt; 'd io) -&gt; 'a -&gt; unit = &lt;fun&gt;

# satisfies_identity_law some_effect 123;;
true
- : unit = ()
# satisfies_identity_law some_other_effect 123;;
true
- : unit = ()
# satisfies_identity_law yet_another_effect 123;;
true
- : unit = ()

# satisfies_associative_law some_effect some_other_effect yet_another_effect 123;;
true
- : unit = ()</code></pre><p>As you can see, monads are very useful for <code>IO</code>. Haskell and Purescript more or less uses some variation of this to achieve pure FP with their <code>IO</code> constructs. Lazy semantics are simulated with functions in Bucklescript and Purescript, and what Purescript does is it keeps the side-effects in a function, threads these functions together using <code>flat_map</code> without evaluating it yet by wrapping the computation in a function, and then the runtime (calling <code>main</code>) or <code>unsafePerformIO</code> will run the side-effects by calling the function. This makes the language &quot;pure&quot; because only the runtime or the unsafe escape hatch can run the effects.</p><p>If you want to see an example of how Purescript-like lazy effects are written in Ocaml, see <a href="https://github.com/Risto-Stevcev/bs-effects">Bs-effects</a>.</p><h5 id="category"><a href="#category" class="anchor"></a>Category</h5><p>Category satisfies the monoid laws at the category level.</p><p>The simples example is <a href="Bastet/Function/Category/index.html"><code>Bastet.Function.Category</code></a>, where <code>empty</code> is the identity function and <code>append</code> is function composition:</p><pre><code class="ml"># let empty x = x;;
val empty : 'a -&gt; 'a = &lt;fun&gt;

# let append f g x = f (g x);;
val append : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = &lt;fun&gt;

# let satisfies_identity_law = (append string_of_int empty) 123 = string_of_int 123;;
val satisfies_identity_law : bool = true

# let satisfies_associative_law =
  (append string_of_int (append ((+) 1) (( * ) 2))) 123 =
  (append (append string_of_int ((+) 1)) (( * ) 2)) 123;;
val satisfies_associative_law : bool = true</code></pre><h4 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h4><p>The comparison interfaces <a href="Bastet/Interface/module-type-EQ/index.html"><code>Bastet.Interface.EQ</code></a> and <a href="Bastet/Interface/module-type-ORD/index.html"><code>Bastet.Interface.ORD</code></a> are self-explanatory: use the <code>EQ</code> interface to define how to determine whether two values of a type are equal, and the <code>ORD</code> interface to define whether two values are <i>greater-than</i>, <i>less-than</i> or <i>equal</i>.</p><h4 id="rings"><a href="#rings" class="anchor"></a>Rings</h4><p>Types that you can both <code>add</code> and <code>multiply</code> are <a href="Bastet/Interface/module-type-SEMIRING/index.html"><code>Bastet.Interface.SEMIRING</code></a>s. If you include <code>subtract</code> you get a <a href="Bastet/Interface/module-type-RING/index.html"><code>Bastet.Interface.RING</code></a>, include <code>divide</code> to that and you get a <a href="Bastet/Interface/module-type-DIVISION_RING/index.html"><code>Bastet.Interface.DIVISION_RING</code></a>, and add <code>modulo</code> to that and you get a <a href="Bastet/Interface/module-type-EUCLIDEAN_RING/index.html"><code>Bastet.Interface.EUCLIDEAN_RING</code></a>.</p><p>These are predominantly useful in situations where <code>monoids</code> aren't enough and you want to be able to use <code>int</code>s and <code>float</code>s without having to write the same function over again.</p><h4 id="lattices"><a href="#lattices" class="anchor"></a>Lattices</h4><p>The most common lattice-like interface is <a href="Bastet/Interface/module-type-BOOLEAN_ALGEBRA/index.html"><code>Bastet.Interface.BOOLEAN_ALGEBRA</code></a> with <code>bool</code> being the most well-known implementation of it.</p><p>Other lattice-like structures in programming come up occasionally. For example, <a href="Bastet/Interface/module-type-JOIN_SEMILATTICE/index.html"><code>Bastet.Interface.JOIN_SEMILATTICE</code></a>s are used to describe <a href="http://groups.csail.mit.edu/genesis/papers/radul%202009.pdf">propagator</a> networks, and <a href="Bastet/Interface/module-type-HEYTING_ALGEBRA/index.html"><code>Bastet.Interface.HEYTING_ALGEBRA</code></a>s are useful for describing fuzzy logics which don't satisfy the law of excluded middle.</p><h4 id="further-reading"><a href="#further-reading" class="anchor"></a>Further Reading</h4><p>You might be wondering if there's more to it then what's described here. For the current state of using these kinds of things in FP there really isn't, but it's fascinating stuff on it's own.</p><p>Wikipedia actually has some pretty nice articles on abstract algebra that are accessible to people who don't have a strong background in math. Reading these is highly recommended:</p><ul><li><a href="https://en.m.wikipedia.org/wiki/Magma_(algebra)">Magma</a></li><li><a href="https://en.m.wikipedia.org/wiki/Semigroup">Semigroup</a></li><li><a href="https://en.m.wikipedia.org/wiki/Monoid">Monoid</a></li><li><a href="https://en.m.wikipedia.org/wiki/Quasigroup">Quasigroup</a></li><li><a href="https://en.m.wikipedia.org/wiki/Quasigroup#Loops">Loop</a></li><li><a href="https://en.m.wikipedia.org/wiki/Group_(mathematics)">Group</a></li><li><a href="https://en.m.wikipedia.org/wiki/Semiring">Semiring</a></li><li><a href="https://en.m.wikipedia.org/wiki/Division_ring">Division Ring</a></li><li><a href="https://en.m.wikipedia.org/wiki/Semilattice">Semilattice</a></li><li><a href="https://en.m.wikipedia.org/wiki/Lattice_(order)#General_lattice">Lattice</a></li><li><a href="https://en.m.wikipedia.org/wiki/Lattice_(order)#Bounded_lattice">Bounded Lattice</a></li><li><a href="https://en.m.wikipedia.org/wiki/Heyting_algebra">Heyting Algebra</a></li><li><a href="https://en.m.wikipedia.org/wiki/Boolean_algebra_(structure)#Definition">Boolean Algebra</a></li></ul><p>And some of the algebraic laws:</p><ul><li><a href="https://en.m.wikipedia.org/wiki/Distributive_property">Distributivity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Associative_property">Associativity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Identity_element">Identity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Commutative_property#Mathematical_definitions">Commutativity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Cancellation_property">Cancellativity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Inverse_element#In_a_unital_magma">Invertibility</a></li></ul><p>There are also different types of relations/relational properties. These are used for the <a href="Bastet/Interface/module-type-EQ/index.html"><code>Bastet.Interface.EQ</code></a> and <a href="Bastet/Interface/module-type-ORD/index.html"><code>Bastet.Interface.ORD</code></a> interfaces, but they also show up with lattice-like structures. They're also good to know if you plan on doing relational or logic programming:</p><ul><li><a href="https://en.m.wikipedia.org/wiki/Reflexive_relation">Reflexivity</a></li><li><a href="https://en.m.wikipedia.org/wiki/Symmetric_relation">Symmetry</a></li><li><a href="https://en.m.wikipedia.org/wiki/Asymmetric_relation">Asymmetry</a></li><li><a href="https://en.m.wikipedia.org/wiki/Antisymmetric_relation">Antisymmetry</a></li><li><a href="https://en.m.wikipedia.org/wiki/Transitive_relation">Transitivity</a></li></ul><h3 id="ppx-let"><a href="#ppx-let" class="anchor"></a>PPX Let</h3><p>You can integrate monads with <a href="https://opam.ocaml.org/packages/ppx_let">ppx_let</a>, a ppx rewriter that provides <em>do notation</em> sugar for <a href="Bastet/Interface/module-type-MONAD/index.html"><code>Bastet.Interface.MONAD</code></a>s. The rewriter expects a <code>Let_syntax</code> module to be in scope, which you can construct using <code>PPX_Let.Make</code>, like so:</p><pre><code class="ml"># #require &quot;fmt&quot;;;
# module OptionLet = PPX_Let.Make(Option.Monad);;
# let add_optionals = fun x y -&gt;
    let open OptionLet in
    let%bind x' = x in
    let%bind y' = y in
    Some (x' + y');;
# Fmt.pr &quot;%a&quot; (Fmt.option Fmt.int) @@ add_optionals (Some 123) (Some 456);;
- : int option = Some 579</code></pre><p>For bucklescript there is the <a href="https://github.com/reasonml-labs/bs-let">bs-let</a> library.</p><h3 id="background"><a href="#background" class="anchor"></a>Background</h3><p>The initial inspiration for the library came from a <code>sequence</code> <a href="https://gist.github.com/Risto-Stevcev/ecfa56d9e87c58a3c20127393c6f283f">demo</a> on the FP slack by <a href="https://github.com/rightfold">rightfold (Chloe)</a> on how to simulate higher kinded types in Ocaml.</p><p>The realization was that there was a better way and that it was possible to write a decent interface in Ocaml using local opens, functors, and avoiding monoid instances for containerized types by relying on their monoidal categories instead, such as <a href="Bastet/Interface/module-type-PLUS/index.html"><code>Bastet.Interface.PLUS</code></a>, <a href="Bastet/Interface/module-type-MONAD/index.html"><code>Bastet.Interface.MONAD</code></a>, and <a href="Bastet/Interface/module-type-CATEGORY/index.html"><code>Bastet.Interface.CATEGORY</code></a>.</p></div></body></html>