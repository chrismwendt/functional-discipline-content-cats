package kan

import cats.{Functor, Monad}

import scala.language.higherKinds
import org.scalatest.funspec.AnyFunSpec
import org.scalatest.matchers.must.Matchers

class RanCustomImpl
  extends AnyFunSpec
    with Matchers {

  describe("Right Kan extension implemented from Haskell definition") {
    /**
     * Right Kan extension of g along h
     *
     * Haskell
     *   newtype Ran g h a = Ran
     *     { runRan :: forall b. (a -> g b) -> h b }
     */
    trait Ran1[G[_], H[_], A] {
      def runRan[B](f: A => G[B]): H[B]
    }

    it("can be instantiated for common type constructors") {
      val r42 = new Ran1[List, Option, Int] {
        def runRan[B](f: Int => List[B]): Option[B] = f(42).headOption
      }

      val rOpt = new Ran1[Option, List, Int] {
        def runRan[B](f: Int => Option[B]): List[B] = f(-11).toList
      }

      r42.runRan(i => List(s"foo $i")) mustBe Some("foo 42")
      rOpt.runRan(i => Some(i)) mustBe List(-11)
    }
  }

  describe("Functor for Right Kan extension") {
    trait Ran2[G[_], H[_], A] { thisRan =>

      def runRan[B](f: A => G[B]): H[B]

      def map[B](f: A => B): Ran2[G, H, B] =
        new Ran2[G, H, B] {
          def runRan[C](f2: B => G[C]): H[C] =
            thisRan.runRan(f andThen f2)
        }
    }

    object RanInstances {

      /**
        * Functor for Ran. It does not depend on the fact that G, H are Functors.
        *
        * Haskell:
        * instance Functor (Ran g h) where
        *    fmap f m = Ran (\\k -> runRan m (k . f))
        */
      def ranFunctor[G[_], H[_]]: Functor[Ran2[G, H, ?]] =
        new Functor[Ran2[G, H, ?]] {
          def map[A, B](fa: Ran2[G, H, A])(f: A => B): Ran2[G, H, B] = fa.map(f)
        }
    }

    it("can use derived methods") {
      val r42 = new Ran2[List, Option, Int] {
        def runRan[B](f: Int => List[B]): Option[B] = f(42).headOption
      }

      val rOpt = new Ran2[Option, List, Int] {
        def runRan[B](f: Int => Option[B]): List[B] = f(-11).toList
      }

      RanInstances.ranFunctor.void(r42).runRan(_ => List(42) ) mustBe Some(42)
    }
  }

  describe("Codensity monad generated from Right Kan Extension of f along itself") {
    trait Ran3[G[_], H[_], A] { thisRan =>

      def runRan[B](f: A => G[B]): H[B]

      def map[B](f: A => B): Ran3[G, H, B] =
        new Ran3[G, H, B] {
          def runRan[C](f2: B => G[C]): H[C] =
            thisRan.runRan(f andThen f2)
        }
    }

    object RanInstances3 {

      /**
        * Functor for Ran. It does not depend on the fact that G, H are Functors.
        *
        * Haskell:
        * instance Functor (Ran g h) where
        *    fmap f m = Ran (\\k -> runRan m (k . f))
        */
      def ranFunctor[G[_], H[_]]: Functor[Ran3[G, H, ?]] =
        new Functor[Ran3[G, H, ?]] {
          def map[A, B](fa: Ran3[G, H, A])(f: A => B): Ran3[G, H, B] = fa.map(f)
        }

      /**
        * Monad generated by Right kan extension of f along itself. It is called Codensity Monad.
        * Haskell:
        *
        * instance Monad (Ran f f) where
        *   return x = Ran (\\k -> k x)
        *   m >>= k = Ran (\\c -> runRan m (\\a -> runRan (k a) c))
        */
      def ranMonad[G[_]]: Monad[Ran3[G, G, ?]] =
        new Monad[Ran3[G, G, ?]] {
          override def map[A, B](fa: Ran3[G, G, A])(f: A => B): Ran3[G, G, B] = fa.map(f)

          override def flatMap[A, B](fa: Ran3[G, G, A])(f: A => Ran3[G, G, B]): Ran3[G, G, B] = flatten(map(fa)(f))

          override def tailRecM[A, B](a: A)(f: A => Ran3[G, G, Either[A, B]]): Ran3[G, G, B] = ???

          override def pure[A](x: A): Ran3[G, G, A] =
            new Ran3[G, G, A] {
              def runRan[C](f2: A => G[C]): G[C] = f2(x)
            }
        }
    }
  }
}
