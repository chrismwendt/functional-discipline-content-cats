package educational.category_theory.kan

import educational.category_theory.Functor

/**
  * Right Kan Extension (Ran G H) of h along g
  *
  * Right Kan Extension in Haskell
  *
  * newtype Ran g h a = Ran
  *   { runRan :: forall b. (a -> g b) -> h b }
  *
  * Right Kan Extension in Category Theory:
  * * We have categories: A, B, C and functors: X : A -> C, F : A -> C
  *   Right Kan Extension of X along F is:
  *   - a functor R : B -> C
  *   - natural transformation (eta) n: RF -> X
  *
  *         X
  *    A ------> C
  *    |       /\
  *  F |      /
  *    |    /  R
  *   \/  /
  *    B
  *
  *   such that for every other candidate:
  *   - functor M : B -> C
  *   - natural transformation u : MF -> X
  *   then there is unique natural transformation d: M -> R such that following diagram commute:
  *
  *         RF
  *    n  /    /\
  *     /        \  dF
  *   \/          \
  *   X ----------> MF
  *         u
  *
  *  where for all a from A: dF(a) = d(Fa): MF(a) -> RF(a)
  */
trait Ran[G[_], H[_], A] {
  def runRan[B](f: A => G[B]): H[B]
}

object RanInstances {

  /* Functor of Ran does not require G, H to be functors, so it is Bifunctor for free ? */

  def ranFunctor[G[_], H[_]]: Functor[Ran[G, H, ?]] =
    new Functor[Ran[G, H, ?]] {

      def map[A, B](fa: Ran[G, H, A])(f: A => B): Ran[G, H, B] =
        new Ran[G, H, B] {
          def runRan[C](f2: B => G[C]): H[C] =
            fa.runRan(f andThen f2)
        }
    }

  // Codensity monad - monad generated by Ran
  def codensityMonad[F[_], A](ran: Ran[F, F, A]): Codensity[F, A] =
    new Codensity[F, A] {
      def run[B](f: A => F[B]): F[B] = ran.runRan(f)
    }
}
